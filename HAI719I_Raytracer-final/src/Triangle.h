#ifndef TRIANGLE_H
#define TRIANGLE_H
#include "Vec3.h"
#include "Ray.h"
#include "Plane.h"
#include "BoundingBox.h"

struct RayTriangleIntersection{
    bool intersectionExists;
    float t;
    float w0,w1,w2;
    unsigned int tIndex;
    Vec3 intersection;
    Vec3 normal;
};

class Triangle {
private:
    Vec3 m_c[3]; // coordinates of the three corners of the triangle
    Vec3 m_normal;
    float area;
public:
    Triangle() {}
    Triangle( Vec3 const & c0 , Vec3 const & c1 , Vec3 const & c2 ) {
        m_c[0] = c0;
        m_c[1] = c1;
        m_c[2] = c2;
        updateAreaAndNormal();
    }
    void updateAreaAndNormal() {
        Vec3 nNotNormalized = Vec3::cross( m_c[1] - m_c[0] , m_c[2] - m_c[0] );
        float norm = nNotNormalized.length();
        m_normal = nNotNormalized / norm;
        area = norm / 2.f;
    }
    void setC0( Vec3 const & c0 ) { m_c[0] = c0; } // remember to update the area and normal afterwards!
    void setC1( Vec3 const & c1 ) { m_c[1] = c1; } // remember to update the area and normal afterwards!
    void setC2( Vec3 const & c2 ) { m_c[2] = c2; } // remember to update the area and normal afterwards!
    Vec3 const & normal() const { return m_normal; }

    Vec3 projectOnSupportPlane( Vec3 const & p ) const {
        Vec3 result;
        //TODO completer
        return result;
    }

    float squareDistanceToSupportPlane( Vec3 const & p ) const {
        float result;
        //TODO completer
        return result;
    }
    float distanceToSupportPlane( Vec3 const & p ) const { return sqrt( squareDistanceToSupportPlane(p) ); }

    bool isParallelTo( Line const & L ) const {
        bool result;

        // check if the normal of the triangle is perpendicular to the direction of the ray
        Vec3 line_dir = L.direction();
        float dot_prod = Vec3::dot(this->m_normal, line_dir);
        if(dot_prod == 0.){
            // the two vectors are perpendicular
            // the triangle is parallel to the ray
            result = true;
        }else{
            result = false;
        }

        return result;
    }

    bool barycentricCoordinatesValidated(Vec3 c0, Vec3 c1, Vec3 c2, float & w0, float & w1, float & w2, Vec3 & p) const{

        Vec3 normal_p_c0_c1, normal_p_c1_c2, normal_p_c0_c2; // normals to the three triangles inside the main triangle

        // normals of the three sub-triangles
        normal_p_c0_c1 = Vec3::cross(c1-c0, p-c0);
        normal_p_c1_c2 = Vec3::cross(c2-c1, p-c1);
        normal_p_c0_c2 = Vec3::cross(c0-c2, p-c2);

        float A_0 = normal_p_c0_c1.length()/2.f;
        float A_1 = normal_p_c1_c2.length()/2.f;
        float A_2 = normal_p_c0_c2.length()/2.f;

        float A = this->area;

        w0 = A_0/A;
        w1 = A_1/A;
        //w2 = A_2/A;
        w2 = 1 - w1 - w0; // sum of coordinates = 1

        // CONVENTION: compute u,v such that p = w0*c0 + w1*c1 + w2*c2, check that 0 <= w0,w1,w2 <= 1
        p = w0*c0 + w1*c1 + w2*c2; // update intersection point

        if (w0 >= 0.0 and w1 >= 0.0 and w2 >= 0.0 and w0 <= 1.0 and w1 <= 1.0 and w2 <= 1.0
            // check that the normals of the sub-triangles point in the same direction as the triangle normal
            and Vec3::dot(normal_p_c0_c1, this->m_normal) > 0
            and Vec3::dot(normal_p_c1_c2, this->m_normal) > 0
            and Vec3::dot(normal_p_c0_c2, this->m_normal) > 0){

            return true;
        }else{
            return false;
        }
    }

    RayTriangleIntersection getIntersection( Ray const & ray ) const {
        RayTriangleIntersection result;

        // check that the ray is not parallel to the triangle:
        if(isParallelTo((Line)ray)){
            result.intersectionExists = false;
        }else{
            // compute intersection with the plane generated by the triangle
            Vec3 a = this->m_c[0]; // any corner of the triangle is a point in plane
            Vec3 p = ray.origin(); // point on ray
            Vec3 n = this->m_normal; // normal to plane
            Vec3 d = ray.direction();

            // intersection ray - plane
            float t = Vec3::dot((a-p),n)/Vec3::dot(d,n);

            if (t > 0.00001) { // check that intersection is in front of the ray
                Vec3 intersection_point = ray.origin() + t * ray.direction();

                // corners of triangle
                Vec3 c0 = this->m_c[0];
                Vec3 c1 = this->m_c[1];
                Vec3 c2 = this->m_c[2];

                float w0, w1, w2; // barycentric coordinates

                // check that the intersection point is inside the triangle:
                if(barycentricCoordinatesValidated(c0, c1, c2, w0, w1, w2, intersection_point)){
                    // if all conditions were met, then there is an intersection!
                    result.intersectionExists = true;
                    result.intersection = intersection_point;
                    result.t = t;
                    result.normal = this->m_normal;
                    result.w0 = w0;
                    result.w1 = w1;
                    result.w2 = w2;
                    // result.tIndex = ??
                } else {
                    result.intersectionExists = false;
                }
            }
        }

        return result;
    }

    bool isInBoundingBox(struct BoundingBox bb){
        // at least one corner must be in the box
        Vec3 c0 = this->m_c[0];
        Vec3 c1 = this->m_c[1];
        Vec3 c2 = this->m_c[2];

        if(c0.isBetween(bb.min_corner, bb.max_corner) ||
           c1.isBetween(bb.min_corner, bb.max_corner) ||
           c2.isBetween(bb.min_corner, bb.max_corner)){
            return true;
        }else{
            return false;
        }
    }
};
#endif
